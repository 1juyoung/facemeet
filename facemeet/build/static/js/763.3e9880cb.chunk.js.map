{"version":3,"file":"static/js/763.3e9880cb.chunk.js","mappings":"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","sources":["pages/MeetingDetail.js"],"sourcesContent":["import React, { useEffect, useRef, useState } from 'react';\r\nimport { io } from 'socket.io-client';\r\nimport './Testjang.css';\r\nimport { useParams } from 'react-router-dom';\r\n\r\nconst MeetingDetail = () => {\r\n    const { meetingId } = useParams(); // URL에서 meetingId 가져오기\r\n    const [roomUsers, setRoomUsers] = useState([]); // 방 내 사용자 목록 관리\r\n    const myStreamRef = useRef(null);\r\n    const peerConnections = useRef({}); // 피어 연결 관리\r\n    const socketRef = useRef(null); // socket.io 객체\r\n    const connectedUsers = useRef([]); // 연결된 사용자 목록\r\n    const [messages, setMessages] = useState([]); // 채팅 메시지 목록\r\n    const [emotionScore, setEmotionScore] = useState(0); // 감정 점수를 위한 상태 추가\r\n\r\n    // 피어 연결 생성 함수\r\n    const createPeerConnection = (userId) => {\r\n        const peerConnection = new RTCPeerConnection();\r\n\r\n        // ICE 후보자 이벤트 처리\r\n        peerConnection.addEventListener(\"icecandidate\", (event) => {\r\n            if (event.candidate) {\r\n                console.log(`Sending ICE candidate to ${userId}`);\r\n                socketRef.current.emit(\"ice\", { ice: event.candidate, roomName: meetingId, toUserId: userId });\r\n            }\r\n        });\r\n\r\n        // 수신된 트랙(비디오) 추가\r\n        peerConnection.addEventListener(\"track\", (event) => {\r\n            let peerFace = document.getElementById(`peerFace-${userId}`);\r\n            if (!peerFace) {\r\n                peerFace = document.createElement(\"video\");\r\n                peerFace.id = `peerFace-${userId}`;\r\n                peerFace.autoplay = true;\r\n                peerFace.playsInline = true;\r\n                document.getElementById(\"peerContainer\").appendChild(peerFace);\r\n            }\r\n            peerFace.srcObject = event.streams[0];\r\n        });\r\n\r\n        peerConnections.current[userId] = peerConnection;\r\n        return peerConnection;\r\n    };\r\n\r\n    // 피어 연결에 트랙 추가\r\n    const addTracksToPeerConnection = (peerConnection) => {\r\n        if (myStreamRef.current) {\r\n            myStreamRef.current.getTracks().forEach((track) => {\r\n                peerConnection.addTrack(track, myStreamRef.current);\r\n            });\r\n        } else {\r\n            console.error(\"myStreamRef.current is null, unable to add tracks.\");\r\n        }\r\n    };\r\n\r\n    // WebRTC 및 소켓 연결 설정\r\n    useEffect(() => {\r\n\r\n        if (!meetingId) {\r\n            console.error(\"Error: meetingId is undefined or null\");\r\n            return;\r\n        }\r\n\r\n        socketRef.current = io(\"http://localhost:4000\");\r\n\r\n        socketRef.current.on(\"connect\", () => {\r\n            console.log(\"Connected to server, socket ID:\", socketRef.current.id);\r\n            socketRef.current.emit('join_room', meetingId);\r\n        });\r\n\r\n        socketRef.current.on(\"disconnect\", () => {\r\n            console.log(\"Disconnected from server\");\r\n        });\r\n\r\n\r\n        // 방에 있는 사용자 목록을 받아 비디오 요소 유무를 확인하고 없는 경우 재연결\r\n        socketRef.current.on(\"room_users\", async (users) => {\r\n            setRoomUsers(users);\r\n            console.log(`Users in room \"${meetingId}\":`, users);\r\n\r\n            users.forEach(async (userId) => {\r\n                if (userId !== socketRef.current.id) { // 본인 제외\r\n                    const peerVideo = document.getElementById(`peerFace-${userId}`);\r\n\r\n                    // 해당 사용자 비디오가 없으면 연결 시도\r\n                    if (!peerVideo) {\r\n                        console.log(`No video found for ${userId}. Attempting to reconnect...`);\r\n\r\n                        if (!connectedUsers.current.includes(userId) && myStreamRef.current) {\r\n                            connectedUsers.current.push(userId);\r\n                            const peerConnection = createPeerConnection(userId);\r\n                            addTracksToPeerConnection(peerConnection);\r\n\r\n                            const offer = await peerConnection.createOffer();\r\n                            await peerConnection.setLocalDescription(offer);\r\n                            console.log(`Sending offer to ${userId} in room: ${meetingId}`);\r\n                            socketRef.current.emit(\"offer\", { offer, toUserId: userId, roomName: meetingId });\r\n                        }\r\n                    }\r\n                }\r\n            });\r\n        });\r\n\r\n        // 방 입장 시 서버에서 다른 사용자가 입장했을 때 실행\r\n        socketRef.current.on(\"welcome\", async ({ userId }) => {\r\n            console.log(`User ${userId} joined room: ${meetingId}`);\r\n            if (!connectedUsers.current.includes(userId) && myStreamRef.current) {\r\n                connectedUsers.current.push(userId); // 연결된 사용자 추가\r\n                const peerConnection = createPeerConnection(userId);\r\n                addTracksToPeerConnection(peerConnection); // 스트림 트랙 추가\r\n                const offer = await peerConnection.createOffer();\r\n                await peerConnection.setLocalDescription(offer);\r\n                console.log(`Sending offer to ${userId} in room: ${meetingId}`);\r\n                socketRef.current.emit(\"offer\", { offer, toUserId: userId, roomName: meetingId });\r\n            }\r\n        });\r\n\r\n        // 사용자 미디어 스트림 가져오기\r\n        const getMedia = async () => {\r\n            try {\r\n                const stream = await navigator.mediaDevices.getUserMedia({\r\n                    audio: true,\r\n                    video: true,\r\n                });\r\n                myStreamRef.current = stream; // 내 미디어 스트림 설정\r\n                document.getElementById(\"myFace\").srcObject = stream; // 내 비디오 화면 설정\r\n                console.log(\"Media stream obtained.\");\r\n            } catch (error) {\r\n                console.error(\"미디어 장치 접근 중 오류 발생\", error);\r\n            }\r\n        };\r\n        // offer 수신 시 처리\r\n        socketRef.current.on('offer', async ({ offer, userId }) => {\r\n            console.log(`Received offer from ${userId} in room: ${meetingId}`);\r\n\r\n            // 미디어 스트림이 없다면 먼저 확보\r\n            if (!myStreamRef.current) {\r\n                await getMedia();\r\n            }\r\n\r\n            if (!connectedUsers.current.includes(userId)) {\r\n                connectedUsers.current.push(userId); // 연결된 사용자 추가\r\n                const peerConnection = createPeerConnection(userId);\r\n                addTracksToPeerConnection(peerConnection); // 스트림 트랙 추가\r\n                await peerConnection.setRemoteDescription(new RTCSessionDescription(offer));\r\n                const answer = await peerConnection.createAnswer();\r\n                await peerConnection.setLocalDescription(answer);\r\n                console.log(`Sending answer to ${userId} in room: ${meetingId}`);\r\n                socketRef.current.emit(\"answer\", { answer, toUserId: userId, roomName: meetingId });\r\n            }\r\n        });\r\n\r\n\r\n        // answer 수신 시 처리\r\n        socketRef.current.on('answer', async ({ answer, userId }) => {\r\n            console.log(`Received answer from ${userId} in room: ${meetingId}`);\r\n\r\n            // 미디어 스트림이 없다면 먼저 확보\r\n            if (!myStreamRef.current) {\r\n                await getMedia();\r\n            }\r\n\r\n            const peerConnection = peerConnections.current[userId];\r\n            if (peerConnection) {\r\n                await peerConnection.setRemoteDescription(new RTCSessionDescription(answer));\r\n            } else {\r\n                console.error(`Peer connection for ${userId} does not exist.`);\r\n            }\r\n        });\r\n\r\n        // 서버에서 ICE 후보자 수신 시 처리\r\n        socketRef.current.on('ice', async ({ ice, userId }) => {\r\n            console.log(`Received ICE candidate from ${userId} in room: ${meetingId}`);\r\n            const peerConnection = peerConnections.current[userId];\r\n            if (peerConnection) {\r\n                try {\r\n                    await peerConnection.addIceCandidate(new RTCIceCandidate(ice));\r\n                } catch (error) {\r\n                    console.error(`Error adding received ICE candidate for ${userId}:, error`);\r\n                }\r\n            } else {\r\n                console.error(`Peer connection for ${userId} does not exist.`);\r\n            }\r\n        });\r\n\r\n        // 채팅 메시지 수신 시 처리\r\n        socketRef.current.on(\"msg\", (data) => {\r\n            setMessages(prevMessages => [...prevMessages, { id: data.id, message: data.message }]);\r\n        });\r\n\r\n        // 사용자의 미디어 스트림 가져오기\r\n        getMedia().then(() => {\r\n            console.log(\"Media stream obtained.\");\r\n        }).catch((error) => {\r\n            console.error(\"Error obtaining media stream:\", error);\r\n        });\r\n\r\n        return () => {\r\n            socketRef.current.disconnect();\r\n        };\r\n    }, [meetingId]);\r\n\r\n    // peerContainer 안의 모든 비디오 요소의 프레임을 캡처하고 서버로 전송하는 함수\r\n    const sendPeerFrames = async () => {\r\n        const peerContainer = document.getElementById(\"peerContainer\");\r\n        const peerVideos = peerContainer.getElementsByTagName(\"video\");\r\n\r\n        for (let video of peerVideos) {\r\n            if (video.readyState >= 2) { // 비디오가 준비된 상태인지 확인\r\n                const canvas = document.createElement(\"canvas\");\r\n                canvas.width = video.videoWidth;\r\n                canvas.height = video.videoHeight;\r\n\r\n                const context = canvas.getContext(\"2d\");\r\n                context.drawImage(video, 0, 0, canvas.width, canvas.height);\r\n                const frameData = canvas.toDataURL(\"image/jpeg\");\r\n\r\n                try {\r\n                    const response = await fetch(\"http://localhost:4001/analyze_emotion\", {\r\n                        method: \"POST\",\r\n                        headers: {\r\n                            \"Content-Type\": \"application/json\",\r\n                        },\r\n                        body: JSON.stringify({ frameData }),\r\n                    });\r\n                    const data = await response.json();\r\n\r\n                    // 감정 점수를 상태에 업데이트하여 화면에 표시되도록 설정\r\n                    if (data.emotionScore) {\r\n                        setEmotionScore(data.emotionScore);\r\n                    }\r\n                } catch (error) {\r\n                    console.error(\"Error sending frame:\", error);\r\n                }\r\n            }\r\n        }\r\n    };\r\n\r\n    // 프레임 캡처 및 전송 - WebRTC와 독립적으로 실행되도록 별도 useEffect 사용\r\n    useEffect(() => {\r\n        const frameInterval = setInterval(() => {\r\n            sendPeerFrames();\r\n        }, 5000); // 5초마다 프레임 전송\r\n\r\n        return () => clearInterval(frameInterval);\r\n    }, []);\r\n\r\n    // 채팅 메시지 전송 핸들러\r\n    const sendMessage = (event) => {\r\n        event.preventDefault();\r\n        let data = document.getElementById(\"chatInput\").value;\r\n        let id = meetingId\r\n        socketRef.current.emit(\"private\", id, data);\r\n        document.getElementById(\"chatInput\").value = \"\";\r\n    };\r\n\r\n    return (\r\n        <div className=\"container-fluid\">\r\n            <div id=\"call\">\r\n                <video id=\"myFace\" autoPlay playsInline height=\"150px\" width=\"150px\"></video>\r\n                <div id=\"peerContainer\">\r\n                    {/* 연결된 사용자들의 비디오가 추가될 자리 */}\r\n                </div>\r\n            </div>\r\n            <div>\r\n                <ul className='peerBox'>\r\n                    <p>Connected Users in Room</p>\r\n                    {roomUsers.map(userId => (\r\n                        <li key={userId}>{userId}</li>\r\n                    ))}\r\n                </ul>\r\n                <div className=\"chatBox\">\r\n                    <div className='chat'>\r\n                        <div className=\"messages\">\r\n                            {messages.map((msg, index) => (\r\n                                <p key={index}><strong>{msg.id}:</strong> {msg.message}</p>\r\n                            ))}\r\n                        </div>\r\n                    </div>\r\n                    <div className='sendBtn'>\r\n                        <form onSubmit={sendMessage}>\r\n                            <input\r\n                                type=\"text\"\r\n                                id=\"chatInput\"\r\n                                className=\"form-control mb-3\"\r\n                                placeholder=\"Enter your message\"\r\n                                autoComplete=\"off\"\r\n                            />\r\n                            <button type=\"submit\" className=\"btn btn-primary\">Send</button>\r\n                        </form>\r\n                    </div>\r\n                </div>\r\n                <div className={`scoreBox ${emotionScore <= 30\r\n                    ? \"red\"\r\n                    : emotionScore <= 70\r\n                        ? \"yellow\"\r\n                        : \"green\"\r\n                    }`}\r\n                >{emotionScore}</div>\r\n            </div>\r\n        </div>\r\n    );\r\n};\r\n\r\nexport default MeetingDetail;"],"names":["MeetingDetail","meetingId","useParams","roomUsers","setRoomUsers","useState","myStreamRef","useRef","peerConnections","socketRef","connectedUsers","messages","setMessages","emotionScore","setEmotionScore","createPeerConnection","userId","peerConnection","RTCPeerConnection","addEventListener","event","candidate","console","log","current","emit","ice","roomName","toUserId","peerFace","document","getElementById","createElement","id","autoplay","playsInline","appendChild","srcObject","streams","addTracksToPeerConnection","getTracks","forEach","track","addTrack","error","useEffect","io","on","async","users","includes","push","offer","createOffer","setLocalDescription","_ref","getMedia","stream","navigator","mediaDevices","getUserMedia","audio","video","_ref2","setRemoteDescription","RTCSessionDescription","answer","createAnswer","_ref3","_ref4","addIceCandidate","RTCIceCandidate","data","prevMessages","message","then","catch","disconnect","frameInterval","setInterval","peerVideos","getElementsByTagName","readyState","canvas","width","videoWidth","height","videoHeight","getContext","drawImage","frameData","toDataURL","response","fetch","method","headers","body","JSON","stringify","json","sendPeerFrames","clearInterval","_jsxs","className","children","_jsx","autoPlay","map","msg","index","onSubmit","preventDefault","value","type","placeholder","autoComplete"],"sourceRoot":""}